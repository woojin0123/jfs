<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 배열 메서드</title>
</head>

<body>
    <script>
        /* 
            배열의 메서드(method)
                1) join([구분자]): 구분자의 기본값은 ,
                : 선택한 여러 옵션을 하나의 문자열로 합쳐서 보여줌
                ex. 태그 등
                2) concat
                : 여러개의 목록을 하나의 큰 목록으로 합칠 때
                ex. 장바구니, 추천 상품 등
                3) reverse
                : 정렬된 목록의 순서를 뒤집을 때
                ex. 최근 작성된 게시물, 댓글을 가장 위에 보여줄 때
                4) sort
                : 숫자 및 내용을 순차적으로 정렬할 때
                ex. 가격 오름/내림차순, 판매량순, 이름순
                5) slice
                : 목록 중 일부만 잘라서 보여줄 때
                ex. 미리보기 (원본 데이터 유지)
                6) splice
                : 특정 내역 삭제, 중간에 새로운 요소 삽입할 때
                ex. 특정 상품 및 회원 제외 (원본 데이터 변경)
                7) pop 8) push
                : 뒤에서 추가/삭제
                ex. 뒤로가기 버튼에서 가장 최근에 방문한 페이지가 맨 뒤에 push되고 뒤로가기를 누르면 맨 뒤 요소가 pop됨
                9) shift 10) unshift
                : 앞에서 추가/삭제
                ex. 대기열 관리할 때 먼저 요청된 것이 먼저 처리될 때 사용
                11) forEach
                : 모든 항목에 동일한 작업 수행 시
                ex. 각 항목 옆에 버튼 추가, 장바구니 내 세금 계산
                12) map
                : 새로운 배열 생성 및 변환
                13) filter
                : 특정 조건을 만족하는 요소만 골라낼 때
                14) indexOf
                : 배열이나 문자열을 앞부터 검색하여 요소와 일치하는 첫번째 항목의 인덱스를 반환
                ex. 중복 확인, 특정 키워드가 처음 언급된 위치 표시
                15) lastIndexOf
                : 배열이나 문자열을 역순으로 검색하지만 앞에서부터 0으로 시작하는 인덱스를 반환
                ex. 가장 마지막에 저장된 파일 위치 찾기, 파일 확장자 찾기
*/

        let result;
        const cities = ['서울', '경기', '인천'];
        // 배열이름.메서드()
        // 배열.join(): ,
        result = cities.join();
        document.write(result + '<br>');
        document.write(typeof result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof cities + '<br>');
        // 배열.join('구분자')
        result = cities.join('-');
        document.write(result + '<br>');
        result = cities.join(' 그리고 ');
        document.write(result + '<br>');

        const fruits = ['사과', '딸기', '포도'];
        const names = ['차길동', '박길동', '김길동'];

        document.write('---------------------<br>');
        // 배열.concat(값, 값, ...)
        result = cities.concat('부산', '광주');
        document.write(result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof result + '<br>');
        // 메서드 체이닝
        result = cities.concat(fruits).join('-');
        document.write(result + '<br>');
        result = cities.concat(fruits, names, '부산');
        document.write(result + '<br>');

        document.write('---------------------<br>');
        const nums = [9, 8, 7, 6, 5, 4, 3, 2, 1];
        result = nums.join();
        document.write(result + '<br>');

        // reverse()
        result = nums.reverse();
        document.write(result + '<br>');
        result = names.join();
        document.write(result + '<br>');
        result = names.reverse();
        document.write(result + '<br>');
        document.write(names + '<br>');

        document.write('---------------------<br>');
        const ndata1 = [19, 38, 67, 26, 55, 24, 53, 12, 31];
        // 숫자의 경우 자리수가 다른 숫자를 정렬할 때 문제 발생! 
        const ndata2 = [132, 2, 41, 123, 45, 1234, 6, 29, 4567];
        const edata = ['Apple', 'Html', 'Game', 'Computer', 'Java'];
        let kdata = ['서울', '부산', '구포', '대구', '인천'];
        // sort() - 오름차순 정렬
        // 1, 2, 3, 4, ...
        // 가, 나, 다, 라, ...
        // a, b, c, d, ...
        result = ndata1.sort();
        document.write(result + '<br>');
        // 함수 데이터: function(){}
        // sort(비교함수)
        // sort(function(a, b){return a - b;})
        // 화살표 함수: sort((a, b)=>a - b;)
        // result = ndata2.sort(
        //     function(a, b){return a - b;}
        // );
        result = ndata2.sort(
            //(a, b)=>{return a - b;}
            (a, b) => a - b
        );
        document.write(result + '<br>');
        result = edata.sort();
        document.write(result + '<br>');
        result = kdata.sort();
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        document.write('---------------------<br>');
        kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종'];
        // slice(인덱스1, [인덱스2]) - 기존 배열은 변경되지 않는다.
        // 인덱스1에서 (인덱스2-1)까지의 값을 새로운 배열로 반환
        result = kdata.slice(0, 4);
        document.write(result + '<br>'); // ['서울', '부산', '구포', '대구']
        result = kdata.slice(-2, -1);
        document.write(result + '<br>'); // ['대전']
        result = kdata.slice(-4, -2);
        document.write(result + '<br>'); // ['대구', '인천']
        document.write(typeof result + '<br>'); // ['대구', '인천']
        document.write(kdata + '<br>'); // ['대구', '인천']

        document.write('---------------------<br>');
        document.write(kdata + '<br>'); // [서울,부산,구포,대구,인천,대전,세종]

        // splice
        // 배열명.splice(시작index, [삭제개수], [요소1, 요소2, ...])
        // - 기존 배열이 변경된다.

        // 요소 삭제 
        // - 1번 인덱스부터 2개를 삭제하여 반환
        document.write(kdata.slice(1, 3) + '<br>');
        result = kdata.splice(1, 2);
        document.write(result + '<br>'); // [부산,구포]
        document.write(kdata + '<br>'); // [서울,대구,인천,대전,세종]

        // 요소 추가
        // 1번 인덱스에 새로운 요소를 추가
        result = kdata.splice(1, 0, "수원", "용인");
        document.write('요소 추가: ' + result + '<br>'); // 
        document.write('kdata: ' + kdata + '<br>'); // [서울,수원,용인,대구,인천,대전,세종]

        // 요소 삭제 - 음수 인덱스
        result = kdata.splice(-2, 1);
        document.write('요소 삭제: ' + result + '<br>'); // [대전]
        document.write('kdata: ' + kdata + '<br>'); // [서울,수원,용인,대구,인천,세종]

        // 2번 인덱스부터 배열의 끝 인덱스까지 반환
        document.write(kdata.slice(2) + '<br>'); // [용인,대구,인천,세종]
        // result = kdata.splice(2, Number.MAX_VALUE); // 4이상의 수를 쓰면 결과는 같다.
        result = kdata.splice(2, 4);
        // 자바스크립트에서 표현할 수 있는 가장 큰 숫자
        console.log(Number.MAX_VALUE); // 1.7976931348623157e+308
        document.write(result + '<br>'); // [용인,대구,인천,세종]
        document.write(kdata + '<br>'); // [서울,수원]

        // 모든 요소 삭제
        //result = kdata.splice(0, 2);
        //result = kdata.splice(0, Number.MAX_VALUE);
        result = kdata.splice(0);
        document.write(result + '<br>'); // [서울,수원]
        document.write('배열 개수: ' + kdata.length + '<br>'); // 배열 개수: 0

        kdata = ['서울', '부산', '구포', '대구', '인천'];
        // push(값, 값, ...)
        // 요소 추가 - 배열의 맨 끝에 추가
        // 스텍(Stack): FILO(First In Last Out) - 먼저 입력된 데이터가 나중 출력된다.
        result = kdata.push('청주', '세종');
        document.write('배열 개수: ' + result + '<br>'); // 배열 개수: 7
        document.write(kdata + '<br>'); // [서울,부산,구포,대구,인천,청주,세종]

        // pop()
        // 요소 삭제 - 배열의 맨 끝 요소를 하나씩 삭제
        result = kdata.pop();
        document.write('삭제한 요소: ' + result + '<br>'); // 세종
        document.write(kdata + '<br>'); // [서울,부산,구포,대구,인천,청주]

        // unshift(값, 값, ...)
        // 요소 추가 - 배열의 맨 앞에 추가
        result = kdata.unshift('경기', '세종');
        document.write('배열 개수: ' + result + '<br>'); // 배열 개수: 8
        document.write(kdata + '<br>'); // [경기,세종,서울,부산,구포,대구,인천,청주]

        // shift()
        // 요소 삭제 - 배열의 맨 앞 요소를 하나씩 삭제
        result = kdata.shift();
        document.write('삭제할 요소: ' + result + '<br>'); // 삭제할 요소: 경기
        document.write(kdata + '<br>'); // [세종,서울,부산,구포,대구,인천,청주]

        // delete 키워드로 삭제한 요소는 undefined를 반환
        // 요소의 개수는 변함이 없다.
        delete kdata[0];
        //delete kdata[1];
        delete kdata[2];
        //delete kdata[3];
        delete kdata[4];
        //delete kdata[5];
        delete kdata[6];
        for (let i = 0; i<kdata.length; i++) {
            document.write(`배열 데이터[${i}] = ${kdata[i]}<br>`);
        }
        document.write('배열 개수: ' + kdata.length + '<br>'); // 배열 개수: 7
        document.write(kdata + '<br>'); // [,,,,,,]

        document.write('--------------------------------<br>')
        kdata=['서울', '부산', '청주', '대구']; 

        // 일반 for
        document.write(`일반 for ------------- <br>`);
        for (let i = 0; i < kdata.length; i++) {
            document.write(`배열 데이터 [${i}] : ${kdata[i]} <br>`);   
        }

        // for~of: index가 없다.
        // for (const 변수 of 배열) {
        document.write(`for ~ of ------------- <br>`);
        for (const val of kdata) {
            document.write(`배열 데이터 : ${val} <br>`);
        }

        // forEach(콜백함수)
        // 배열명.forEach(function(val, idx, [arr]){
        //     코드;
        // });
        // - 배열을 반복하며 저장된 데이터를 조회
        // 배열의 index를 사용!
        document.write(`forEach() ------------- <br>`);
        kdata.forEach(function (val, idx) {
            document.write(`배열 데이터 [${idx}] : ${val} <br>`);
        });

        // 10개의 배열 요소 합
        let datas = [1,2,3,4,5,3,7,8,3,10];
        let sum = 0;
        datas.forEach(function (val) {
            sum += val;
        });
        document.write(`10개의 배열 요소 합: ${sum} <br>`); // 46
        console.log(datas);

        document.write(`map() ------------- <br>`);
        // map() - 새 배열 생성
        // map(콜백함수)
        // 배열명.map(function(val, [idx], [arr]){});
        result = datas.map(function(val){
            return val * val;
        });
        document.write(`기존 배열: ${datas} <br>`); // [1,2,3,4,5,3,7,8,3,10]
        document.write(`새 배열: ${result} <br>`); // [1,4,9,16,25,9,49,64,9,100]


        document.write(`filter() ------------- <br>`);
        // filter() - 새 배열 생성
        // filter(콜백함수)
        // 배열명.filter(function(val, [idx], [arr]){
        //       return 조건식;
        // });
        result = datas.filter(function(val){
            return val >= 6;
        });
        document.write(`기존 배열: ${datas} <br>`); // [1,2,3,4,5,3,7,8,3,10]
        document.write(`새 배열: ${result} <br>`); // [7,8,10]

        document.write(`indexOf()/lastIndexOf() ------------- <br>`);
        // indexOf(val, [fromIdx]) 
        // - val에 대한 인덱스 반환, 앞에서 부터
        // - fromIdx: 검색을 시작할 인덱스
        // lastIndexOf(val, [fromIdx]) 
        // - val에 대한 인덱스 반환, 뒤에서 부터

        // 처음에서 첫 번째로 찾은 3의 인덱스를 반환
        document.write('인덱스: ' + datas.indexOf(3) + '<br>'); // 인덱스: 2
        // 2번 인덱스부터 끝방향으로 3을 찾는다
        document.write('인덱스: ' + datas.indexOf(3, 2) + '<br>'); // 인덱스: 5
        // 끝에서 첫 번째로 찾은 3의 인덱스를 반환
        document.write('인덱스: ' + datas.lastIndexOf(3) + '<br>'); // 인덱스: 8
        // 3번 인덱스부터 시작방향으로 3을 찾아서 인덱스를 반환
        document.write('인덱스: ' + datas.lastIndexOf(3, 3) + '<br>'); // 인덱스: 2
    </script>
</body>

</html>