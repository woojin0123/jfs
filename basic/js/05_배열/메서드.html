<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS: 배열 메서드</title>
</head>
<body>
    <script>
/* 
배열의 method
    1. join (연결자)
    2. concat
    3. reverse
    4. sort
    5. slice
    6. splice
    7. pop
    8. push
    9. shift
    10. unshift
    11. forEach
    12. map
    13. filter
    14. indexOf
    15. lastIndexOf
*/

 let result;
        const cities = ['서울', '경기', '인천'];
        // 배열이름.메서드()
        // 배열.join(): ,
        result = cities.join();
        document.write(result + '<br>');
        document.write(typeof result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof cities + '<br>');
        // 배열.join('구분자')
        result = cities.join('-');
        document.write(result + '<br>');
        result = cities.join(' 그리고 ');
        document.write(result + '<br>');

        const fruits = ['사과', '딸기', '포도'];
        const names = ['차길동', '박길동', '김길동'];

        document.write('---------------------<br>');
        // 배열.concat(값, 값, ...)
        result = cities.concat('부산', '광주');
        document.write(result + '<br>');
        document.write(cities + '<br>');
        document.write(typeof result + '<br>');
        // 메서드 체이닝
        result = cities.concat(fruits).join('-');
        document.write(result + '<br>');
        result = cities.concat(fruits, names, '부산');
        document.write(result + '<br>');

        document.write('---------------------<br>');
        const nums = [9, 8, 7, 6, 5, 4, 3, 2, 1];
        result = nums.join();
        document.write(result + '<br>');

        // reverse()
        result = nums.reverse();
        document.write(result + '<br>');
        result = names.join();
        document.write(result + '<br>');
        result = names.reverse();
        document.write(result + '<br>');
        document.write(names + '<br>');

        document.write('---------------------<br>');
        const ndata1 = [19, 38, 67, 26, 55, 24, 53, 12, 31];
        // 숫자의 경우 자리수가 다른 숫자를 정렬할 때 문제 발생! 
        const ndata2 = [132, 2, 41, 123, 45, 1234, 6, 29, 4567];
        const edata = ['Apple', 'Html', 'Game', 'Computer', 'Java'];
        let kdata = ['서울', '부산', '구포', '대구', '인천'];
        // sort() - 오름차순 정렬
        // 1, 2, 3, 4, ...
        // 가, 나, 다, 라, ...
        // a, b, c, d, ...
        result = ndata1.sort();
        document.write(result + '<br>');
        // 함수 데이터: function(){}
        // sort(비교함수)
        // sort(function(a, b){return a - b;})
        // 화살표 함수: sort((a, b)=>a - b;)
        // result = ndata2.sort(
        //     function(a, b){return a - b;}
        // );
        result = ndata2.sort(
            //(a, b)=>{return a - b;}
            (a, b) => a - b
        );
        document.write(result + '<br>');
        result = edata.sort();
        document.write(result + '<br>');
        result = kdata.sort();
        document.write(result + '<br>');
        document.write(kdata + '<br>');

        document.write('---------------------<br>');
        kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종']; 
        // slice(인덱스1, 인덱스2)
        // 인덱스1에서 (인덱스2-1)까지의 값을 새로운 배열로 반환
        result = kdata.slice(0, 4);
        document.write(result + '<br>'); // ['서울', '부산', '구포', '대구']
        result = kdata.slice(-2, -1); 
        document.write(result + '<br>'); // ['대전']
        result = kdata.slice(-4, -2);
        document.write(result + '<br>'); // ['대구', '인천']
        document.write(typeof result + '<br>'); // ['대구', '인천']
        document.write(kdata + '<br>'); // ['대구', '인천']

        document.write('---------------------<br>');
        // kdata = ['서울', '부산', '구포', '대구', '인천', '대전', '세종']; 
        document.write(kdata + '<br>'); // 서울,부산,구포,대구,인천,대전,세종

        // splice: 기존 배열이 변경됨
        // 1번 인덱스부터 2개를 삭제하여 변환
        document.write(kdata.slice(1, 3) + '<br>') // 부산,구포
        result = kdata.splice(1, 2);
        document.write(result + '<br>'); // 부산,구포
        document.write(kdata + '<br>'); // 서울,대구,인천,대전,세종

        // 1번 인덱스부터 1개의 요소 삭제 후 그 자리에 새로운 요소를 추가하여 반환
        result = kdata.splice(1, 1, '수원', '용인');
        document.write(result + '<br>'); // 대구
        document.write(kdata + '<br>'); // 서울,수원,용인,인천,대전,세종

        // 배열명.splice(시작index, 삭제 갯수, 아이템)
        // 2번 인덱스부터 배열의 끝 인덱스까지 반환
        result = kdata.splice(2, Number.MAX_VALUE);
        document.write(result + '<br>'); // 용인,인천,대전,세종
        document.write(kdata + '<br>'); // 서울,수원


        document.write('---------------------<br>');
        // forEach(): 배열을 반복하며 저장된 데이터를 조회
        kdata=['서울', '부산', '청주', '대구'];
        function printArr(item, index) {
            document.write(`배열 데이터 [${index}] : ${item} <br>`);
        }
        kdata.forEach()

    </script>
</body>
</html>